{
  "layout": {
    "about": "О нас",
    "algorithms": "Алгоритмы",
    "kruskal": "Алгоритм Краскала",
    "prim": "Алгоритм Прима",
    "dijkstra": "Алгоритм Дейкстры",
    "floyd": "Алгоритм Флойда",
    "footer": "© {{ year }} - Алгоритмы",
    "edge": "Ребро",
    "algorithms_and_methods": "Алгоритмы и методы",
    "questions": "Вопросы"
  },
  "about": {
    "title": "О нас",
    "purpose_title": "Цель сайта",
    "purpose_text": "Этот сайт создан как образовательный инструмент, чтобы помочь студентам и энтузиастам понять и визуализировать четыре фундаментальных алгоритма на графах: алгоритмы Краскала, Прима, Дейкстры и Флойда-Уоршалла. Каждый алгоритм представлен с интерактивными инструментами, позволяющими вводить данные графа, изучать пошаговое выполнение и визуализировать результаты, способствуя более глубокому пониманию теории графов и алгоритмического решения задач. Платформа стремится сократить разрыв между теоретическими концепциями и практическим применением, предлагая опыт работы с визуализациями графов в реальном времени, делая сложные идеи более доступными и увлекательными для учащихся всех уровней.",
    "team_title": "Наша команда",
    "developers": [
      {
        "name": "Артём Портов",
        "role": "Создал страницы 'О нас' и алгоритм Прима. Помог разработать стиль фона."
      },
      {
        "name": "Василиса Савинская",
        "role": "Разработала главную страницу сайта и страницу для алгоритма Краскала."
      },
      {
        "name": "Дарья Равилова",
        "role": "Разработала страницу для алгоритма Флойда-Уоршалла."
      },
      {
        "name": "Карина Балабанова",
        "role": "Разработала страницу с часто задаваемыми вопросами и создала страницу для алгоритма Дейкстры."
      }
    ]
  },
  "index": {
    "title": "Алгоритмы и методы",
    "call_to_action": "Нужна помощь в решении задач на графах с визуальной ясностью? Выберите нужный алгоритм и рассчитывайте с лёгкостью!",
    "kruskal_description": "Алгоритм Краскала: Жадный алгоритм для нахождения минимального остовного дерева (MST) в графе путём добавления наименьшего ребра, не образующего цикл.",
    "prim_description": "Алгоритм Прима: Другой жадный подход для нахождения MST, вырастающий дерево по одной вершине за раз от начальной вершины.",
    "dijkstra_description": "Алгоритм Дейкстры: Алгоритм нахождения кратчайшего пути, определяющий минимальное расстояние от исходной вершины до всех остальных вершин в графе с неотрицательными весами.",
    "floyd_description": "Алгоритм Флойда: Алгоритм динамического программирования, вычисляющий кратчайшие пути между всеми парами вершин во взвешенном графе."
  },
  "prim": {
    "title": "Алгоритм Прима",
    "theory_title": "Алгоритм Прима: Подробный разбор",
    "theory_description": "Алгоритм Прима — это жадный алгоритм, используемый для нахождения минимального остовного дерева (MST) в связном взвешенном неориентированном графе. MST — это подмножество рёбер, которое соединяет все вершины с минимальной общей массой рёбер, не образуя циклов.",
    "theory_how_it_works": "Как это работает",
    "theory_steps": [
      "Начните с произвольной вершины: Выберите любую вершину графа для начала. Эта вершина станет корнем минимального остовного дерева (MST).",
      "Добавляйте наименьшее ребро: Из множества рёбер, соединяющих текущее MST с непосещённой вершиной, выберите ребро с наименьшим весом и добавьте его в MST.",
      "Повторяйте, пока все вершины не будут включены: Продолжайте добавлять рёбра с наименьшими весами, пока все вершины графа не станут частью MST."
    ],
    "theory_result": "Результатом будет дерево, охватывающее все вершины с минимально возможным суммарным весом рёбер.",
    "theory_example_title": "Пример работы алгоритма Прима",
    "theory_example_text": "Рассмотрим граф с 4 вершинами (A, B, C, D) и следующими взвешенными рёбрами:",
    "theory_example_edges": [
      "A-B с весом 1",
      "A-C с весом 3",
      "B-C с весом 3",
      "B-D с весом 6",
      "C-D с весом 4"
    ],
    "theory_example_start": "Начиная с вершины A, алгоритм выполняется следующим образом:",
    "theory_example_steps": [
      "Выберите вершину A в качестве начальной точки. MST изначально пусто.",
      "Добавьте наименьшее ребро от A: A-B (вес 1). MST = {A-B}.",
      "Из вершин A и B наименьшее ребро к непосещённой вершине — A-C (вес 3). Добавьте A-C. MST = {A-B, A-C}.",
      "Из вершин A, B, C наименьшее ребро к непосещённой вершине — C-D (вес 4). Добавьте C-D. MST = {A-B, A-C, C-D}."
    ],
    "theory_example_result": "Итоговое MST содержит рёбра A-B (1), A-C (3) и C-D (4), с общим весом 8.",
    "theory_applications_title": "Применение алгоритма Прима",
    "theory_applications_text": "Алгоритм Прима широко используется в различных областях, где требуется минимальная остовная структура. Некоторые практические применения включают:",
    "theory_applications_list": [
      "Проектирование сетей: Построение экономичных сетей, таких как электрические сети или телекоммуникационные системы.",
      "Кластерный анализ: Группировка данных в машинном обучении путём соединения точек с минимальными расстояниями.",
      "Планирование маршрутов: Поиск эффективных маршрутов в робототехнике или логистике, минимизируя общую дистанцию или стоимость."
    ],
    "calculator_input_title": "Ввод данных",
    "calculator_input_vertices": "Количество вершин:",
    "calculator_input_mode": "Режим весов:",
    "calculator_input_mode_manual": "Ручной",
    "calculator_input_mode_auto": "Автоматический",
    "calculator_input_create": "Создать граф",
    "calculator_input_weights_title": "Веса рёбер",
    "calculator_input_confirm": "Подтвердить",
    "calculator_graph_title": "Граф",
    "calculator_graph_instruction": "Введите данные графа выше, чтобы увидеть визуализацию.",
    "calculator_mst_title": "Минимальное остовное дерево (MST)",
    "calculator_mst_weight": "Общий вес MST: 0",
    "calculator_skip_to": "Перейти к калькулятору"
  },
  "dijkstra": {
    "title": "Алгоритм Дейкстры",
    "header": {
      "title": "Алгоритм Дейкстры",
      "description": "Найдите кратчайший путь от одного источника к конкретной целевой вершине в взвешенном графе"
    },
    "panel": {
      "title": "Настройка матрицы",
      "vertices_label": "Вершины:",
      "start_vertex_label": "Начальная вершина:",
      "end_vertex_label": "Конечная вершина:",
      "generate_button": "Сгенерировать случайный граф",
      "calculate_button": "Найти кратчайший путь",
      "adjacency_matrix_title": "Матрица смежности",
      "result_title": "Результат кратчайшего пути"
    },
    "theory": {
      "title": "Теория алгоритма",
      "concept": {
        "title": "Концепция",
        "description": "Алгоритм Дейкстры находит кратчайший путь от начальной вершины ко всем другим вершинам во взвешенном графе с неотрицательными весами рёбер. Он поддерживает множество посещённых вершин и обновляет кратчайшие расстояния, используя очередь с приоритетами или жадный подход."
      },
      "steps": {
        "title": "Шаги",
        "initialization": {
          "title": "Инициализация",
          "steps": [
            "Установите расстояние до источника = 0",
            "Установите расстояния до всех остальных вершин = ∞",
            "Пометить все вершины как непосещённые"
          ]
        },
        "relaxation": {
          "title": "Релаксация",
          "description": "Повторяйте:",
          "steps": [
            "Выберите непосещённую вершину с наименьшим расстоянием",
            "Обновите расстояния до её соседей, если найден более короткий путь",
            "Пометить текущую вершину как посещённую"
          ]
        },
        "termination": {
          "title": "Завершение",
          "description": "Когда все вершины посещены, алгоритм завершается. Расстояния представляют собой кратчайшие пути от источника ко всем другим вершинам."
        }
      }
    },
    "example": {
      "title": "Пример",
      "initial_graph": {
        "title": "Исходный граф",
        "adjacency_matrix_title": "Матрица смежности",
        "adjacency_matrix": "    A   B   C   D   E\nA [ 0,  50, ∞,   ∞,   90]\nB [∞,   0,  90,  ∞,   ∞]\nC [∞,   ∞,   0,  80,  60]\nD [∞,   ∞,   ∞,   0,  70]\nE [∞,   ∞,   ∞,   ∞,   0]",
        "graph_visualization_title": "Визуализация графа"
      },
      "execution": {
        "title": "Пошаговое выполнение от A (источника)",
        "iterations": [
          {
            "title": "Итерация 1 (Начало с A)",
            "content": "Посещённые: A\nРасстояния: A=0, B=50, C=∞, D=∞, E=90"
          },
          {
            "title": "Итерация 2 (Выбор B)",
            "content": "Посещённые: A, B\nРасстояния: A=0, B=50, C=140 (через B), D=∞, E=90"
          },
          {
            "title": "Итерация 3 (Выбор E)",
            "content": "Посещённые: A, B, E\nРасстояния: A=0, B=50, C=140, D=160 (через E), E=90"
          },
          {
            "title": "Итерация 4 (Выбор C)",
            "content": "Посещённые: A, B, E, C\nРасстояния: A=0, B=50, C=140, D=160, E=90"
          },
          {
            "title": "Итерация 5 (Выбор D)",
            "content": "Посещённые: A, B, E, C, D\nРасстояния: A=0, B=50, C=140, D=160, E=90"
          }
        ]
      },
      "final_result": {
        "title": "Итоговые кратчайшие расстояния от A",
        "content": "\nA → B → C → D (50 + 90 + 80 = 220)\nA → E → D (90 + 70 = 160)\nA → B → C → E → D (50 + 90 + 60 + 70 = 270)\n\n**Кратчайший путь от A до D:** A → E → D с общим весом = 160"
      }
    }
  },
  "floyd": {
    "title": "Алгоритм Флойда",
    "header": {
      "title": "Алгоритм Флойда-Уоршалла",
      "description": "Найдите кратчайшие пути между всеми парами вершин во взвешенном графе"
    },
    "panel": {
      "title": "Настройка матрицы",
      "vertices_label": "Вершины:",
      "generate_button": "Сгенерировать случайный граф",
      "calculate_button": "Рассчитать пути",
      "input_matrix_title": "Входная матрица",
      "result_title": "Результирующая матрица (кратчайшие пути)",
      "path_title": "Матрица путей"
    },
    "theory": {
      "title": "Теория алгоритма",
      "core_principle": {
        "title": "Основной принцип",
        "description": "Алгоритм Флойда-Уоршалла решает задачу поиска кратчайших путей между всеми парами вершин через динамическое программирование. Он строит решение, постепенно улучшая оценки кратчайших путей между всеми парами вершин."
      },
      "steps": {
        "title": "Шаги алгоритма",
        "initialization": {
          "title": "Фаза инициализации",
          "description": "Создайте матрицу расстояний D, где:",
          "steps": [
            "D[i][j] = вес ребра от i к j (если существует)",
            "D[i][j] = ∞, если прямого соединения нет",
            "D[i][i] = 0 для всех вершин"
          ]
        },
        "relaxation": {
          "title": "Фаза релаксации",
          "description": "Для каждой промежуточной вершины k (от 1 до n):",
          "code": "D[i][j] = min(D[i][j], D[i][k] + D[k][j])",
          "text": "Это проверяет, является ли путь через k короче текущей оценки."
        },
        "termination": {
          "title": "Интерпретация результата",
          "description": "Конечная матрица содержит кратчайшие пути между всеми парами. Отрицательные значения на диагонали указывают на наличие отрицательных циклов."
        }
      }
    },
    "example": {
      "title": "Подробный пример",
      "initial_graph": {
        "title": "Исходный граф",
        "adjacency_matrix_title": "Матрица смежности",
        "adjacency_matrix": "   A  B   C  D\nA [0, 3, ∞, 7]\nB [8, 0, 2, ∞]\nC [5, ∞, 0, 1]\nD [2, ∞, ∞, 0]",
        "graph_visualization_title": "Визуализация графа"
      },
      "execution": {
        "title": "Процесс итераций",
        "iterations": [
          {
            "title": "После k=A (Промежуточная вершина A)",
            "content": "   A  B   C   D\nA [0, 3, ∞, 7]\nB [8, 0, 2, 15]  <-  B-D обновлено через A (8+7)\nC [5, 8, 0, 1]   <-  C-B обновлено через A (5+3)\nD [2, 5, ∞, 0]   <-  D-B обновлено через A (2+3)"
          },
          {
            "title": "Итоговый результат (k=D)",
            "content": "   A  B  C D\nA [0, 3, 5,6]  <-  A-D через C (5+1)\nB [5, 0, 2,3]  <-  B-A через D (8+2)\nC [3, 6, 0,1]  <-  C-A через D (5+2)\nD [2, 5, 7,0]  <-  D-C через B (∞ -> 5+2)"
          }
        ]
      },
      "path_reconstruction": {
        "title": "Восстановление пути",
        "description": "Чтобы найти путь от B до D (стоимость=3):",
        "steps": [
          "Проверьте промежуточные вершины в обратном порядке",
          "B -> A -> D (стоимость 8+7=15) -> не оптимально",
          "B -> C -> D (стоимость 2+1=3) <- оптимальный путь"
        ]
      }
    }
  }
}